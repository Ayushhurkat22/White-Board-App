{"ast":null,"code":"import { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nimport { parsePath, normalize, absolutize } from 'path-data-parser';\nconst helper = {\n  randOffset,\n  randOffsetWithRange,\n  ellipse,\n  doubleLineOps: doubleLineFillOps\n};\nexport function line(x1, y1, x2, y2, o) {\n  return {\n    type: 'path',\n    ops: _doubleLine(x1, y1, x2, y2, o)\n  };\n}\nexport function linearPath(points, close, o) {\n  const len = (points || []).length;\n  if (len > 2) {\n    const ops = [];\n    for (let i = 0; i < len - 1; i++) {\n      ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n    }\n    if (close) {\n      ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n    }\n    return {\n      type: 'path',\n      ops\n    };\n  } else if (len === 2) {\n    return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n  }\n  return {\n    type: 'path',\n    ops: []\n  };\n}\nexport function polygon(points, o) {\n  return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n  const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n  return polygon(points, o);\n}\nexport function curve(inputPoints, o) {\n  if (inputPoints.length) {\n    const p1 = inputPoints[0];\n    const pointsList = typeof p1[0] === 'number' ? [inputPoints] : inputPoints;\n    const o1 = _curveWithOffset(pointsList[0], 1 * (1 + o.roughness * 0.2), o);\n    const o2 = o.disableMultiStroke ? [] : _curveWithOffset(pointsList[0], 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n    for (let i = 1; i < pointsList.length; i++) {\n      const points = pointsList[i];\n      if (points.length) {\n        const underlay = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n        const overlay = o.disableMultiStroke ? [] : _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n        for (const item of underlay) {\n          if (item.op !== 'move') {\n            o1.push(item);\n          }\n        }\n        for (const item of overlay) {\n          if (item.op !== 'move') {\n            o2.push(item);\n          }\n        }\n      }\n    }\n    return {\n      type: 'path',\n      ops: o1.concat(o2)\n    };\n  }\n  return {\n    type: 'path',\n    ops: []\n  };\n}\nexport function ellipse(x, y, width, height, o) {\n  const params = generateEllipseParams(width, height, o);\n  return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n  const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n  const stepCount = Math.ceil(Math.max(o.curveStepCount, o.curveStepCount / Math.sqrt(200) * psq));\n  const increment = Math.PI * 2 / stepCount;\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  const curveFitRandomness = 1 - o.curveFitting;\n  rx += _offsetOpt(rx * curveFitRandomness, o);\n  ry += _offsetOpt(ry * curveFitRandomness, o);\n  return {\n    increment,\n    rx,\n    ry\n  };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n  const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n  let o1 = _curve(ap1, null, o);\n  if (!o.disableMultiStroke && o.roughness !== 0) {\n    const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n    const o2 = _curve(ap2, null, o);\n    o1 = o1.concat(o2);\n  }\n  return {\n    estimatedPoints: cp1,\n    opset: {\n      type: 'path',\n      ops: o1\n    }\n  };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n  const cx = x;\n  const cy = y;\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  rx += _offsetOpt(rx * 0.01, o);\n  ry += _offsetOpt(ry * 0.01, o);\n  let strt = start;\n  let stp = stop;\n  while (strt < 0) {\n    strt += Math.PI * 2;\n    stp += Math.PI * 2;\n  }\n  if (stp - strt > Math.PI * 2) {\n    strt = 0;\n    stp = Math.PI * 2;\n  }\n  const ellipseInc = Math.PI * 2 / o.curveStepCount;\n  const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n  const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n  if (!o.disableMultiStroke) {\n    const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n    ops.push(...o2);\n  }\n  if (closed) {\n    if (roughClosure) {\n      ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n    } else {\n      ops.push({\n        op: 'lineTo',\n        data: [cx, cy]\n      }, {\n        op: 'lineTo',\n        data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)]\n      });\n    }\n  }\n  return {\n    type: 'path',\n    ops\n  };\n}\nexport function svgPath(path, o) {\n  const segments = normalize(absolutize(parsePath(path)));\n  const ops = [];\n  let first = [0, 0];\n  let current = [0, 0];\n  for (const {\n    key,\n    data\n  } of segments) {\n    switch (key) {\n      case 'M':\n        {\n          current = [data[0], data[1]];\n          first = [data[0], data[1]];\n          break;\n        }\n      case 'L':\n        ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n        current = [data[0], data[1]];\n        break;\n      case 'C':\n        {\n          const [x1, y1, x2, y2, x, y] = data;\n          ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n          current = [x, y];\n          break;\n        }\n      case 'Z':\n        ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n        current = [first[0], first[1]];\n        break;\n    }\n  }\n  return {\n    type: 'path',\n    ops\n  };\n}\n// Fills\nexport function solidFillPolygon(polygonList, o) {\n  const ops = [];\n  for (const points of polygonList) {\n    if (points.length) {\n      const offset = o.maxRandomnessOffset || 0;\n      const len = points.length;\n      if (len > 2) {\n        ops.push({\n          op: 'move',\n          data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]\n        });\n        for (let i = 1; i < len; i++) {\n          ops.push({\n            op: 'lineTo',\n            data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]\n          });\n        }\n      }\n    }\n  }\n  return {\n    type: 'fillPath',\n    ops\n  };\n}\nexport function patternFillPolygons(polygonList, o) {\n  return getFiller(o, helper).fillPolygons(polygonList, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n  const cx = x;\n  const cy = y;\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  rx += _offsetOpt(rx * 0.01, o);\n  ry += _offsetOpt(ry * 0.01, o);\n  let strt = start;\n  let stp = stop;\n  while (strt < 0) {\n    strt += Math.PI * 2;\n    stp += Math.PI * 2;\n  }\n  if (stp - strt > Math.PI * 2) {\n    strt = 0;\n    stp = Math.PI * 2;\n  }\n  const increment = (stp - strt) / o.curveStepCount;\n  const points = [];\n  for (let angle = strt; angle <= stp; angle = angle + increment) {\n    points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n  }\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  points.push([cx, cy]);\n  return patternFillPolygons([points], o);\n}\nexport function randOffset(x, o) {\n  return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n  return _offset(min, max, o);\n}\nexport function doubleLineFillOps(x1, y1, x2, y2, o) {\n  return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n  const result = Object.assign({}, ops);\n  result.randomizer = undefined;\n  if (ops.seed) {\n    result.seed = ops.seed + 1;\n  }\n  return result;\n}\nfunction random(ops) {\n  if (!ops.randomizer) {\n    ops.randomizer = new Random(ops.seed || 0);\n  }\n  return ops.randomizer.next();\n}\nfunction _offset(min, max, ops, roughnessGain = 1) {\n  return ops.roughness * roughnessGain * (random(ops) * (max - min) + min);\n}\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n  return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n  const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n  const o1 = _line(x1, y1, x2, y2, o, true, false);\n  if (singleStroke) {\n    return o1;\n  }\n  const o2 = _line(x1, y1, x2, y2, o, true, true);\n  return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n  const lengthSq = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\n  const length = Math.sqrt(lengthSq);\n  let roughnessGain = 1;\n  if (length < 200) {\n    roughnessGain = 1;\n  } else if (length > 500) {\n    roughnessGain = 0.4;\n  } else {\n    roughnessGain = -0.0016668 * length + 1.233334;\n  }\n  let offset = o.maxRandomnessOffset || 0;\n  if (offset * offset * 100 > lengthSq) {\n    offset = length / 10;\n  }\n  const halfOffset = offset / 2;\n  const divergePoint = 0.2 + random(o) * 0.2;\n  let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n  let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n  midDispX = _offsetOpt(midDispX, o, roughnessGain);\n  midDispY = _offsetOpt(midDispY, o, roughnessGain);\n  const ops = [];\n  const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n  const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n  const preserveVertices = o.preserveVertices;\n  if (move) {\n    if (overlay) {\n      ops.push({\n        op: 'move',\n        data: [x1 + (preserveVertices ? 0 : randomHalf()), y1 + (preserveVertices ? 0 : randomHalf())]\n      });\n    } else {\n      ops.push({\n        op: 'move',\n        data: [x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)), y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain))]\n      });\n    }\n  }\n  if (overlay) {\n    ops.push({\n      op: 'bcurveTo',\n      data: [midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(), midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(), midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(), midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(), x2 + (preserveVertices ? 0 : randomHalf()), y2 + (preserveVertices ? 0 : randomHalf())]\n    });\n  } else {\n    ops.push({\n      op: 'bcurveTo',\n      data: [midDispX + x1 + (x2 - x1) * divergePoint + randomFull(), midDispY + y1 + (y2 - y1) * divergePoint + randomFull(), midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(), midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(), x2 + (preserveVertices ? 0 : randomFull()), y2 + (preserveVertices ? 0 : randomFull())]\n    });\n  }\n  return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n  if (!points.length) {\n    return [];\n  }\n  const ps = [];\n  ps.push([points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]);\n  ps.push([points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]);\n  for (let i = 1; i < points.length; i++) {\n    ps.push([points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]);\n    if (i === points.length - 1) {\n      ps.push([points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]);\n    }\n  }\n  return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n  const len = points.length;\n  const ops = [];\n  if (len > 3) {\n    const b = [];\n    const s = 1 - o.curveTightness;\n    ops.push({\n      op: 'move',\n      data: [points[1][0], points[1][1]]\n    });\n    for (let i = 1; i + 2 < len; i++) {\n      const cachedVertArray = points[i];\n      b[0] = [cachedVertArray[0], cachedVertArray[1]];\n      b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n      b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n      b[3] = [points[i + 1][0], points[i + 1][1]];\n      ops.push({\n        op: 'bcurveTo',\n        data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]]\n      });\n    }\n    if (closePoint && closePoint.length === 2) {\n      const ro = o.maxRandomnessOffset;\n      ops.push({\n        op: 'lineTo',\n        data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)]\n      });\n    }\n  } else if (len === 3) {\n    ops.push({\n      op: 'move',\n      data: [points[1][0], points[1][1]]\n    });\n    ops.push({\n      op: 'bcurveTo',\n      data: [points[1][0], points[1][1], points[2][0], points[2][1], points[2][0], points[2][1]]\n    });\n  } else if (len === 2) {\n    ops.push(..._line(points[0][0], points[0][1], points[1][0], points[1][1], o, true, true));\n  }\n  return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n  const coreOnly = o.roughness === 0;\n  const corePoints = [];\n  const allPoints = [];\n  if (coreOnly) {\n    increment = increment / 4;\n    allPoints.push([cx + rx * Math.cos(-increment), cy + ry * Math.sin(-increment)]);\n    for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n      const p = [cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)];\n      corePoints.push(p);\n      allPoints.push(p);\n    }\n    allPoints.push([cx + rx * Math.cos(0), cy + ry * Math.sin(0)]);\n    allPoints.push([cx + rx * Math.cos(increment), cy + ry * Math.sin(increment)]);\n  } else {\n    const radOffset = _offsetOpt(0.5, o) - Math.PI / 2;\n    allPoints.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);\n    const endAngle = Math.PI * 2 + radOffset - 0.01;\n    for (let angle = radOffset; angle < endAngle; angle = angle + increment) {\n      const p = [_offsetOpt(offset, o) + cx + rx * Math.cos(angle), _offsetOpt(offset, o) + cy + ry * Math.sin(angle)];\n      corePoints.push(p);\n      allPoints.push(p);\n    }\n    allPoints.push([_offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5), _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)]);\n    allPoints.push([_offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap), _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)]);\n    allPoints.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)]);\n  }\n  return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n  const radOffset = strt + _offsetOpt(0.1, o);\n  const points = [];\n  points.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);\n  for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n    points.push([_offsetOpt(offset, o) + cx + rx * Math.cos(angle), _offsetOpt(offset, o) + cy + ry * Math.sin(angle)]);\n  }\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n  const ops = [];\n  const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n  let f = [0, 0];\n  const iterations = o.disableMultiStroke ? 1 : 2;\n  const preserveVertices = o.preserveVertices;\n  for (let i = 0; i < iterations; i++) {\n    if (i === 0) {\n      ops.push({\n        op: 'move',\n        data: [current[0], current[1]]\n      });\n    } else {\n      ops.push({\n        op: 'move',\n        data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))]\n      });\n    }\n    f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n    ops.push({\n      op: 'bcurveTo',\n      data: [x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o), x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o), f[0], f[1]]\n    });\n  }\n  return ops;\n}","map":{"version":3,"names":["getFiller","Random","parsePath","normalize","absolutize","helper","randOffset","randOffsetWithRange","ellipse","doubleLineOps","doubleLineFillOps","line","x1","y1","x2","y2","o","type","ops","_doubleLine","linearPath","points","close","len","length","i","push","polygon","rectangle","x","y","width","height","curve","inputPoints","p1","pointsList","o1","_curveWithOffset","roughness","o2","disableMultiStroke","cloneOptionsAlterSeed","underlay","overlay","item","op","concat","params","generateEllipseParams","ellipseWithParams","opset","psq","Math","sqrt","PI","pow","stepCount","ceil","max","curveStepCount","increment","rx","abs","ry","curveFitRandomness","curveFitting","_offsetOpt","ellipseParams","ap1","cp1","_computeEllipsePoints","_offset","_curve","ap2","estimatedPoints","arc","start","stop","closed","roughClosure","cx","cy","strt","stp","ellipseInc","arcInc","min","_arc","cos","sin","data","svgPath","path","segments","first","current","key","_bezierTo","solidFillPolygon","polygonList","offset","maxRandomnessOffset","patternFillPolygons","fillPolygons","patternFillArc","angle","result","Object","assign","randomizer","undefined","seed","random","next","roughnessGain","filling","singleStroke","disableMultiStrokeFill","_line","move","lengthSq","halfOffset","divergePoint","midDispX","bowing","midDispY","randomHalf","randomFull","preserveVertices","ps","closePoint","b","s","curveTightness","cachedVertArray","ro","overlap","coreOnly","corePoints","allPoints","p","radOffset","endAngle","ros","f","iterations"],"sources":["C:/Users/Ayush Hurkat/Documents/whiteboard-app/node_modules/roughjs/bin/renderer.js"],"sourcesContent":["import { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nimport { parsePath, normalize, absolutize } from 'path-data-parser';\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps: doubleLineFillOps,\n};\nexport function line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nexport function linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        const ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nexport function polygon(points, o) {\n    return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height],\n    ];\n    return polygon(points, o);\n}\nexport function curve(inputPoints, o) {\n    if (inputPoints.length) {\n        const p1 = inputPoints[0];\n        const pointsList = (typeof p1[0] === 'number') ? [inputPoints] : inputPoints;\n        const o1 = _curveWithOffset(pointsList[0], 1 * (1 + o.roughness * 0.2), o);\n        const o2 = o.disableMultiStroke ? [] : _curveWithOffset(pointsList[0], 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n        for (let i = 1; i < pointsList.length; i++) {\n            const points = pointsList[i];\n            if (points.length) {\n                const underlay = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n                const overlay = o.disableMultiStroke ? [] : _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n                for (const item of underlay) {\n                    if (item.op !== 'move') {\n                        o1.push(item);\n                    }\n                }\n                for (const item of overlay) {\n                    if (item.op !== 'move') {\n                        o2.push(item);\n                    }\n                }\n            }\n        }\n        return { type: 'path', ops: o1.concat(o2) };\n    }\n    return { type: 'path', ops: [] };\n}\nexport function ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.ceil(Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq));\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    let o1 = _curve(ap1, null, o);\n    if ((!o.disableMultiStroke) && (o.roughness !== 0)) {\n        const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n        const o2 = _curve(ap2, null, o);\n        o1 = o1.concat(o2);\n    }\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1 },\n    };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    if (!o.disableMultiStroke) {\n        const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        ops.push(...o2);\n    }\n    if (closed) {\n        if (roughClosure) {\n            ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] }, { op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nexport function svgPath(path, o) {\n    const segments = normalize(absolutize(parsePath(path)));\n    const ops = [];\n    let first = [0, 0];\n    let current = [0, 0];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M': {\n                current = [data[0], data[1]];\n                first = [data[0], data[1]];\n                break;\n            }\n            case 'L':\n                ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n                current = [data[0], data[1]];\n                break;\n            case 'C': {\n                const [x1, y1, x2, y2, x, y] = data;\n                ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n                current = [x, y];\n                break;\n            }\n            case 'Z':\n                ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n                current = [first[0], first[1]];\n                break;\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nexport function solidFillPolygon(polygonList, o) {\n    const ops = [];\n    for (const points of polygonList) {\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n                }\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nexport function patternFillPolygons(polygonList, o) {\n    return getFiller(o, helper).fillPolygons(polygonList, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygons([points], o);\n}\nexport function randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nexport function doubleLineFillOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n    const result = Object.assign({}, ops);\n    result.randomizer = undefined;\n    if (ops.seed) {\n        result.seed = ops.seed + 1;\n    }\n    return result;\n}\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops, roughnessGain = 1) {\n    return ops.roughness * roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n    return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n    const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    if (singleStroke) {\n        return o1;\n    }\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    let roughnessGain = 1;\n    if (length < 200) {\n        roughnessGain = 1;\n    }\n    else if (length > 500) {\n        roughnessGain = 0.4;\n    }\n    else {\n        roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o, roughnessGain);\n    midDispY = _offsetOpt(midDispY, o, roughnessGain);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n    const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n    const preserveVertices = o.preserveVertices;\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : randomHalf()),\n                    y1 + (preserveVertices ? 0 : randomHalf()),\n                ],\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                    y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                ],\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + (preserveVertices ? 0 : randomHalf()),\n                y2 + (preserveVertices ? 0 : randomHalf()),\n            ],\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + (preserveVertices ? 0 : randomFull()),\n                y2 + (preserveVertices ? 0 : randomFull()),\n            ],\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    if (!points.length) {\n        return [];\n    }\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    const ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1],\n            ],\n        });\n    }\n    else if (len === 2) {\n        ops.push(..._line(points[0][0], points[0][1], points[1][0], points[1][1], o, true, true));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const coreOnly = o.roughness === 0;\n    const corePoints = [];\n    const allPoints = [];\n    if (coreOnly) {\n        increment = increment / 4;\n        allPoints.push([\n            cx + rx * Math.cos(-increment),\n            cy + ry * Math.sin(-increment),\n        ]);\n        for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n            const p = [\n                cx + rx * Math.cos(angle),\n                cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            cx + rx * Math.cos(0),\n            cy + ry * Math.sin(0),\n        ]);\n        allPoints.push([\n            cx + rx * Math.cos(increment),\n            cy + ry * Math.sin(increment),\n        ]);\n    }\n    else {\n        const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n        ]);\n        const endAngle = Math.PI * 2 + radOffset - 0.01;\n        for (let angle = radOffset; angle < endAngle; angle = angle + increment) {\n            const p = [\n                _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n                _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5),\n        ]);\n    }\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n    let f = [0, 0];\n    const iterations = o.disableMultiStroke ? 1 : 2;\n    const preserveVertices = o.preserveVertices;\n    for (let i = 0; i < iterations; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [current[0], current[1]] });\n        }\n        else {\n            ops.push({ op: 'move', data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))] });\n        }\n        f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1],\n            ],\n        });\n    }\n    return ops;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}