{"ast":null,"code":"import { line, solidFillPolygon, patternFillPolygons, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math.js';\nimport { curveToBezier } from 'points-on-curve/lib/curve-to-bezier.js';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { pointsOnPath } from 'points-on-path';\nconst NOS = 'none';\nexport class RoughGenerator {\n  constructor(config) {\n    this.defaultOptions = {\n      maxRandomnessOffset: 2,\n      roughness: 1,\n      bowing: 1,\n      stroke: '#000',\n      strokeWidth: 1,\n      curveTightness: 0,\n      curveFitting: 0.95,\n      curveStepCount: 9,\n      fillStyle: 'hachure',\n      fillWeight: -1,\n      hachureAngle: -41,\n      hachureGap: -1,\n      dashOffset: -1,\n      dashGap: -1,\n      zigzagOffset: -1,\n      seed: 0,\n      disableMultiStroke: false,\n      disableMultiStrokeFill: false,\n      preserveVertices: false,\n      fillShapeRoughnessGain: 0.8\n    };\n    this.config = config || {};\n    if (this.config.options) {\n      this.defaultOptions = this._o(this.config.options);\n    }\n  }\n  static newSeed() {\n    return randomSeed();\n  }\n  _o(options) {\n    return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n  }\n  _d(shape, sets, options) {\n    return {\n      shape,\n      sets: sets || [],\n      options: options || this.defaultOptions\n    };\n  }\n  line(x1, y1, x2, y2, options) {\n    const o = this._o(options);\n    return this._d('line', [line(x1, y1, x2, y2, o)], o);\n  }\n  rectangle(x, y, width, height, options) {\n    const o = this._o(options);\n    const paths = [];\n    const outline = rectangle(x, y, width, height, o);\n    if (o.fill) {\n      const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n      if (o.fillStyle === 'solid') {\n        paths.push(solidFillPolygon([points], o));\n      } else {\n        paths.push(patternFillPolygons([points], o));\n      }\n    }\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n    return this._d('rectangle', paths, o);\n  }\n  ellipse(x, y, width, height, options) {\n    const o = this._o(options);\n    const paths = [];\n    const ellipseParams = generateEllipseParams(width, height, o);\n    const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n    if (o.fill) {\n      if (o.fillStyle === 'solid') {\n        const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n        shape.type = 'fillPath';\n        paths.push(shape);\n      } else {\n        paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o));\n      }\n    }\n    if (o.stroke !== NOS) {\n      paths.push(ellipseResponse.opset);\n    }\n    return this._d('ellipse', paths, o);\n  }\n  circle(x, y, diameter, options) {\n    const ret = this.ellipse(x, y, diameter, diameter, options);\n    ret.shape = 'circle';\n    return ret;\n  }\n  linearPath(points, options) {\n    const o = this._o(options);\n    return this._d('linearPath', [linearPath(points, false, o)], o);\n  }\n  arc(x, y, width, height, start, stop, closed = false, options) {\n    const o = this._o(options);\n    const paths = [];\n    const outline = arc(x, y, width, height, start, stop, closed, true, o);\n    if (closed && o.fill) {\n      if (o.fillStyle === 'solid') {\n        const fillOptions = Object.assign({}, o);\n        fillOptions.disableMultiStroke = true;\n        const shape = arc(x, y, width, height, start, stop, true, false, fillOptions);\n        shape.type = 'fillPath';\n        paths.push(shape);\n      } else {\n        paths.push(patternFillArc(x, y, width, height, start, stop, o));\n      }\n    }\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n    return this._d('arc', paths, o);\n  }\n  curve(points, options) {\n    const o = this._o(options);\n    const paths = [];\n    const outline = curve(points, o);\n    if (o.fill && o.fill !== NOS) {\n      if (o.fillStyle === 'solid') {\n        const fillShape = curve(points, Object.assign(Object.assign({}, o), {\n          disableMultiStroke: true,\n          roughness: o.roughness ? o.roughness + o.fillShapeRoughnessGain : 0\n        }));\n        paths.push({\n          type: 'fillPath',\n          ops: this._mergedShape(fillShape.ops)\n        });\n      } else {\n        const polyPoints = [];\n        const inputPoints = points;\n        if (inputPoints.length) {\n          const p1 = inputPoints[0];\n          const pointsList = typeof p1[0] === 'number' ? [inputPoints] : inputPoints;\n          for (const points of pointsList) {\n            if (points.length < 3) {\n              polyPoints.push(...points);\n            } else if (points.length === 3) {\n              polyPoints.push(...pointsOnBezierCurves(curveToBezier([points[0], points[0], points[1], points[2]]), 10, (1 + o.roughness) / 2));\n            } else {\n              polyPoints.push(...pointsOnBezierCurves(curveToBezier(points), 10, (1 + o.roughness) / 2));\n            }\n          }\n        }\n        if (polyPoints.length) {\n          paths.push(patternFillPolygons([polyPoints], o));\n        }\n      }\n    }\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n    return this._d('curve', paths, o);\n  }\n  polygon(points, options) {\n    const o = this._o(options);\n    const paths = [];\n    const outline = linearPath(points, true, o);\n    if (o.fill) {\n      if (o.fillStyle === 'solid') {\n        paths.push(solidFillPolygon([points], o));\n      } else {\n        paths.push(patternFillPolygons([points], o));\n      }\n    }\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n    return this._d('polygon', paths, o);\n  }\n  path(d, options) {\n    const o = this._o(options);\n    const paths = [];\n    if (!d) {\n      return this._d('path', paths, o);\n    }\n    d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n    const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n    const hasStroke = o.stroke !== NOS;\n    const simplified = !!(o.simplification && o.simplification < 1);\n    const distance = simplified ? 4 - 4 * (o.simplification || 1) : (1 + o.roughness) / 2;\n    const sets = pointsOnPath(d, 1, distance);\n    const shape = svgPath(d, o);\n    if (hasFill) {\n      if (o.fillStyle === 'solid') {\n        if (sets.length === 1) {\n          const fillShape = svgPath(d, Object.assign(Object.assign({}, o), {\n            disableMultiStroke: true,\n            roughness: o.roughness ? o.roughness + o.fillShapeRoughnessGain : 0\n          }));\n          paths.push({\n            type: 'fillPath',\n            ops: this._mergedShape(fillShape.ops)\n          });\n        } else {\n          paths.push(solidFillPolygon(sets, o));\n        }\n      } else {\n        paths.push(patternFillPolygons(sets, o));\n      }\n    }\n    if (hasStroke) {\n      if (simplified) {\n        sets.forEach(set => {\n          paths.push(linearPath(set, false, o));\n        });\n      } else {\n        paths.push(shape);\n      }\n    }\n    return this._d('path', paths, o);\n  }\n  opsToPath(drawing, fixedDecimals) {\n    let path = '';\n    for (const item of drawing.ops) {\n      const data = typeof fixedDecimals === 'number' && fixedDecimals >= 0 ? item.data.map(d => +d.toFixed(fixedDecimals)) : item.data;\n      switch (item.op) {\n        case 'move':\n          path += `M${data[0]} ${data[1]} `;\n          break;\n        case 'bcurveTo':\n          path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n          break;\n        case 'lineTo':\n          path += `L${data[0]} ${data[1]} `;\n          break;\n      }\n    }\n    return path.trim();\n  }\n  toPaths(drawable) {\n    const sets = drawable.sets || [];\n    const o = drawable.options || this.defaultOptions;\n    const paths = [];\n    for (const drawing of sets) {\n      let path = null;\n      switch (drawing.type) {\n        case 'path':\n          path = {\n            d: this.opsToPath(drawing),\n            stroke: o.stroke,\n            strokeWidth: o.strokeWidth,\n            fill: NOS\n          };\n          break;\n        case 'fillPath':\n          path = {\n            d: this.opsToPath(drawing),\n            stroke: NOS,\n            strokeWidth: 0,\n            fill: o.fill || NOS\n          };\n          break;\n        case 'fillSketch':\n          path = this.fillSketch(drawing, o);\n          break;\n      }\n      if (path) {\n        paths.push(path);\n      }\n    }\n    return paths;\n  }\n  fillSketch(drawing, o) {\n    let fweight = o.fillWeight;\n    if (fweight < 0) {\n      fweight = o.strokeWidth / 2;\n    }\n    return {\n      d: this.opsToPath(drawing),\n      stroke: o.fill || NOS,\n      strokeWidth: fweight,\n      fill: NOS\n    };\n  }\n  _mergedShape(input) {\n    return input.filter((d, i) => {\n      if (i === 0) {\n        return true;\n      }\n      if (d.op === 'move') {\n        return false;\n      }\n      return true;\n    });\n  }\n}","map":{"version":3,"names":["line","solidFillPolygon","patternFillPolygons","rectangle","ellipseWithParams","generateEllipseParams","linearPath","arc","patternFillArc","curve","svgPath","randomSeed","curveToBezier","pointsOnBezierCurves","pointsOnPath","NOS","RoughGenerator","constructor","config","defaultOptions","maxRandomnessOffset","roughness","bowing","stroke","strokeWidth","curveTightness","curveFitting","curveStepCount","fillStyle","fillWeight","hachureAngle","hachureGap","dashOffset","dashGap","zigzagOffset","seed","disableMultiStroke","disableMultiStrokeFill","preserveVertices","fillShapeRoughnessGain","options","_o","newSeed","Object","assign","_d","shape","sets","x1","y1","x2","y2","o","x","y","width","height","paths","outline","fill","points","push","ellipse","ellipseParams","ellipseResponse","opset","type","estimatedPoints","circle","diameter","ret","start","stop","closed","fillOptions","fillShape","ops","_mergedShape","polyPoints","inputPoints","length","p1","pointsList","polygon","path","d","replace","hasFill","hasStroke","simplified","simplification","distance","forEach","set","opsToPath","drawing","fixedDecimals","item","data","map","toFixed","op","trim","toPaths","drawable","fillSketch","fweight","input","filter","i"],"sources":["C:/Users/Ayush Hurkat/Documents/whiteboard-app/node_modules/roughjs/bin/generator.js"],"sourcesContent":["import { line, solidFillPolygon, patternFillPolygons, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math.js';\nimport { curveToBezier } from 'points-on-curve/lib/curve-to-bezier.js';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { pointsOnPath } from 'points-on-path';\nconst NOS = 'none';\nexport class RoughGenerator {\n    constructor(config) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            disableMultiStroke: false,\n            disableMultiStrokeFill: false,\n            preserveVertices: false,\n            fillShapeRoughnessGain: 0.8,\n        };\n        this.config = config || {};\n        if (this.config.options) {\n            this.defaultOptions = this._o(this.config.options);\n        }\n    }\n    static newSeed() {\n        return randomSeed();\n    }\n    _o(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _d(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._o(options);\n        return this._d('line', [line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = rectangle(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const ellipseParams = generateEllipseParams(width, height, o);\n        const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._d('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._o(options);\n        return this._d('linearPath', [linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = arc(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const fillOptions = Object.assign({}, o);\n                fillOptions.disableMultiStroke = true;\n                const shape = arc(x, y, width, height, start, stop, true, false, fillOptions);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = curve(points, o);\n        if (o.fill && o.fill !== NOS) {\n            if (o.fillStyle === 'solid') {\n                const fillShape = curve(points, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                paths.push({\n                    type: 'fillPath',\n                    ops: this._mergedShape(fillShape.ops),\n                });\n            }\n            else {\n                const polyPoints = [];\n                const inputPoints = points;\n                if (inputPoints.length) {\n                    const p1 = inputPoints[0];\n                    const pointsList = (typeof p1[0] === 'number') ? [inputPoints] : inputPoints;\n                    for (const points of pointsList) {\n                        if (points.length < 3) {\n                            polyPoints.push(...points);\n                        }\n                        else if (points.length === 3) {\n                            polyPoints.push(...pointsOnBezierCurves(curveToBezier([\n                                points[0],\n                                points[0],\n                                points[1],\n                                points[2],\n                            ]), 10, (1 + o.roughness) / 2));\n                        }\n                        else {\n                            polyPoints.push(...pointsOnBezierCurves(curveToBezier(points), 10, (1 + o.roughness) / 2));\n                        }\n                    }\n                }\n                if (polyPoints.length) {\n                    paths.push(patternFillPolygons([polyPoints], o));\n                }\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('curve', paths, o);\n    }\n    polygon(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = linearPath(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._o(options);\n        const paths = [];\n        if (!d) {\n            return this._d('path', paths, o);\n        }\n        d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n        const hasStroke = o.stroke !== NOS;\n        const simplified = !!(o.simplification && (o.simplification < 1));\n        const distance = simplified ? (4 - 4 * (o.simplification || 1)) : ((1 + o.roughness) / 2);\n        const sets = pointsOnPath(d, 1, distance);\n        const shape = svgPath(d, o);\n        if (hasFill) {\n            if (o.fillStyle === 'solid') {\n                if (sets.length === 1) {\n                    const fillShape = svgPath(d, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                    paths.push({\n                        type: 'fillPath',\n                        ops: this._mergedShape(fillShape.ops),\n                    });\n                }\n                else {\n                    paths.push(solidFillPolygon(sets, o));\n                }\n            }\n            else {\n                paths.push(patternFillPolygons(sets, o));\n            }\n        }\n        if (hasStroke) {\n            if (simplified) {\n                sets.forEach((set) => {\n                    paths.push(linearPath(set, false, o));\n                });\n            }\n            else {\n                paths.push(shape);\n            }\n        }\n        return this._d('path', paths, o);\n    }\n    opsToPath(drawing, fixedDecimals) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS,\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS,\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS,\n        };\n    }\n    _mergedShape(input) {\n        return input.filter((d, i) => {\n            if (i === 0) {\n                return true;\n            }\n            if (d.op === 'move') {\n                return false;\n            }\n            return true;\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}