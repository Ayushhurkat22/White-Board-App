{"ast":null,"code":"function rotatePoints(points, center, degrees) {\n  if (points && points.length) {\n    const [cx, cy] = center;\n    const angle = Math.PI / 180 * degrees;\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    for (const p of points) {\n      const [x, y] = p;\n      p[0] = (x - cx) * cos - (y - cy) * sin + cx;\n      p[1] = (x - cx) * sin + (y - cy) * cos + cy;\n    }\n  }\n}\nfunction rotateLines(lines, center, degrees) {\n  const points = [];\n  lines.forEach(line => points.push(...line));\n  rotatePoints(points, center, degrees);\n}\nfunction areSamePoints(p1, p2) {\n  return p1[0] === p2[0] && p1[1] === p2[1];\n}\nexport function hachureLines(polygons, hachureGap, hachureAngle, hachureStepOffset = 1) {\n  const angle = hachureAngle;\n  const gap = Math.max(hachureGap, 0.1);\n  const polygonList = polygons[0] && polygons[0][0] && typeof polygons[0][0] === 'number' ? [polygons] : polygons;\n  const rotationCenter = [0, 0];\n  if (angle) {\n    for (const polygon of polygonList) {\n      rotatePoints(polygon, rotationCenter, angle);\n    }\n  }\n  const lines = straightHachureLines(polygonList, gap, hachureStepOffset);\n  if (angle) {\n    for (const polygon of polygonList) {\n      rotatePoints(polygon, rotationCenter, -angle);\n    }\n    rotateLines(lines, rotationCenter, -angle);\n  }\n  return lines;\n}\nfunction straightHachureLines(polygons, gap, hachureStepOffset) {\n  const vertexArray = [];\n  for (const polygon of polygons) {\n    const vertices = [...polygon];\n    if (!areSamePoints(vertices[0], vertices[vertices.length - 1])) {\n      vertices.push([vertices[0][0], vertices[0][1]]);\n    }\n    if (vertices.length > 2) {\n      vertexArray.push(vertices);\n    }\n  }\n  const lines = [];\n  gap = Math.max(gap, 0.1);\n  // Create sorted edges table\n  const edges = [];\n  for (const vertices of vertexArray) {\n    for (let i = 0; i < vertices.length - 1; i++) {\n      const p1 = vertices[i];\n      const p2 = vertices[i + 1];\n      if (p1[1] !== p2[1]) {\n        const ymin = Math.min(p1[1], p2[1]);\n        edges.push({\n          ymin,\n          ymax: Math.max(p1[1], p2[1]),\n          x: ymin === p1[1] ? p1[0] : p2[0],\n          islope: (p2[0] - p1[0]) / (p2[1] - p1[1])\n        });\n      }\n    }\n  }\n  edges.sort((e1, e2) => {\n    if (e1.ymin < e2.ymin) {\n      return -1;\n    }\n    if (e1.ymin > e2.ymin) {\n      return 1;\n    }\n    if (e1.x < e2.x) {\n      return -1;\n    }\n    if (e1.x > e2.x) {\n      return 1;\n    }\n    if (e1.ymax === e2.ymax) {\n      return 0;\n    }\n    return (e1.ymax - e2.ymax) / Math.abs(e1.ymax - e2.ymax);\n  });\n  if (!edges.length) {\n    return lines;\n  }\n  // Start scanning\n  let activeEdges = [];\n  let y = edges[0].ymin;\n  let iteration = 0;\n  while (activeEdges.length || edges.length) {\n    if (edges.length) {\n      let ix = -1;\n      for (let i = 0; i < edges.length; i++) {\n        if (edges[i].ymin > y) {\n          break;\n        }\n        ix = i;\n      }\n      const removed = edges.splice(0, ix + 1);\n      removed.forEach(edge => {\n        activeEdges.push({\n          s: y,\n          edge\n        });\n      });\n    }\n    activeEdges = activeEdges.filter(ae => {\n      if (ae.edge.ymax <= y) {\n        return false;\n      }\n      return true;\n    });\n    activeEdges.sort((ae1, ae2) => {\n      if (ae1.edge.x === ae2.edge.x) {\n        return 0;\n      }\n      return (ae1.edge.x - ae2.edge.x) / Math.abs(ae1.edge.x - ae2.edge.x);\n    });\n    // fill between the edges\n    if (hachureStepOffset !== 1 || iteration % gap === 0) {\n      if (activeEdges.length > 1) {\n        for (let i = 0; i < activeEdges.length; i = i + 2) {\n          const nexti = i + 1;\n          if (nexti >= activeEdges.length) {\n            break;\n          }\n          const ce = activeEdges[i].edge;\n          const ne = activeEdges[nexti].edge;\n          lines.push([[Math.round(ce.x), y], [Math.round(ne.x), y]]);\n        }\n      }\n    }\n    y += hachureStepOffset;\n    activeEdges.forEach(ae => {\n      ae.edge.x = ae.edge.x + hachureStepOffset * ae.edge.islope;\n    });\n    iteration++;\n  }\n  return lines;\n}","map":{"version":3,"names":["rotatePoints","points","center","degrees","length","cx","cy","angle","Math","PI","cos","sin","p","x","y","rotateLines","lines","forEach","line","push","areSamePoints","p1","p2","hachureLines","polygons","hachureGap","hachureAngle","hachureStepOffset","gap","max","polygonList","rotationCenter","polygon","straightHachureLines","vertexArray","vertices","edges","i","ymin","min","ymax","islope","sort","e1","e2","abs","activeEdges","iteration","ix","removed","splice","edge","s","filter","ae","ae1","ae2","nexti","ce","ne","round"],"sources":["C:/Users/Ayush Hurkat/Documents/whiteboard-app/node_modules/hachure-fill/bin/hachure.js"],"sourcesContent":["function rotatePoints(points, center, degrees) {\n    if (points && points.length) {\n        const [cx, cy] = center;\n        const angle = (Math.PI / 180) * degrees;\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        for (const p of points) {\n            const [x, y] = p;\n            p[0] = ((x - cx) * cos) - ((y - cy) * sin) + cx;\n            p[1] = ((x - cx) * sin) + ((y - cy) * cos) + cy;\n        }\n    }\n}\nfunction rotateLines(lines, center, degrees) {\n    const points = [];\n    lines.forEach((line) => points.push(...line));\n    rotatePoints(points, center, degrees);\n}\nfunction areSamePoints(p1, p2) {\n    return p1[0] === p2[0] && p1[1] === p2[1];\n}\nexport function hachureLines(polygons, hachureGap, hachureAngle, hachureStepOffset = 1) {\n    const angle = hachureAngle;\n    const gap = Math.max(hachureGap, 0.1);\n    const polygonList = (polygons[0] && polygons[0][0] && (typeof polygons[0][0] === 'number')) ? [polygons] : polygons;\n    const rotationCenter = [0, 0];\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, angle);\n        }\n    }\n    const lines = straightHachureLines(polygonList, gap, hachureStepOffset);\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, -angle);\n        }\n        rotateLines(lines, rotationCenter, -angle);\n    }\n    return lines;\n}\nfunction straightHachureLines(polygons, gap, hachureStepOffset) {\n    const vertexArray = [];\n    for (const polygon of polygons) {\n        const vertices = [...polygon];\n        if (!areSamePoints(vertices[0], vertices[vertices.length - 1])) {\n            vertices.push([vertices[0][0], vertices[0][1]]);\n        }\n        if (vertices.length > 2) {\n            vertexArray.push(vertices);\n        }\n    }\n    const lines = [];\n    gap = Math.max(gap, 0.1);\n    // Create sorted edges table\n    const edges = [];\n    for (const vertices of vertexArray) {\n        for (let i = 0; i < vertices.length - 1; i++) {\n            const p1 = vertices[i];\n            const p2 = vertices[i + 1];\n            if (p1[1] !== p2[1]) {\n                const ymin = Math.min(p1[1], p2[1]);\n                edges.push({\n                    ymin,\n                    ymax: Math.max(p1[1], p2[1]),\n                    x: ymin === p1[1] ? p1[0] : p2[0],\n                    islope: (p2[0] - p1[0]) / (p2[1] - p1[1]),\n                });\n            }\n        }\n    }\n    edges.sort((e1, e2) => {\n        if (e1.ymin < e2.ymin) {\n            return -1;\n        }\n        if (e1.ymin > e2.ymin) {\n            return 1;\n        }\n        if (e1.x < e2.x) {\n            return -1;\n        }\n        if (e1.x > e2.x) {\n            return 1;\n        }\n        if (e1.ymax === e2.ymax) {\n            return 0;\n        }\n        return (e1.ymax - e2.ymax) / Math.abs((e1.ymax - e2.ymax));\n    });\n    if (!edges.length) {\n        return lines;\n    }\n    // Start scanning\n    let activeEdges = [];\n    let y = edges[0].ymin;\n    let iteration = 0;\n    while (activeEdges.length || edges.length) {\n        if (edges.length) {\n            let ix = -1;\n            for (let i = 0; i < edges.length; i++) {\n                if (edges[i].ymin > y) {\n                    break;\n                }\n                ix = i;\n            }\n            const removed = edges.splice(0, ix + 1);\n            removed.forEach((edge) => {\n                activeEdges.push({ s: y, edge });\n            });\n        }\n        activeEdges = activeEdges.filter((ae) => {\n            if (ae.edge.ymax <= y) {\n                return false;\n            }\n            return true;\n        });\n        activeEdges.sort((ae1, ae2) => {\n            if (ae1.edge.x === ae2.edge.x) {\n                return 0;\n            }\n            return (ae1.edge.x - ae2.edge.x) / Math.abs((ae1.edge.x - ae2.edge.x));\n        });\n        // fill between the edges\n        if ((hachureStepOffset !== 1) || (iteration % gap === 0)) {\n            if (activeEdges.length > 1) {\n                for (let i = 0; i < activeEdges.length; i = i + 2) {\n                    const nexti = i + 1;\n                    if (nexti >= activeEdges.length) {\n                        break;\n                    }\n                    const ce = activeEdges[i].edge;\n                    const ne = activeEdges[nexti].edge;\n                    lines.push([\n                        [Math.round(ce.x), y],\n                        [Math.round(ne.x), y],\n                    ]);\n                }\n            }\n        }\n        y += hachureStepOffset;\n        activeEdges.forEach((ae) => {\n            ae.edge.x = ae.edge.x + (hachureStepOffset * ae.edge.islope);\n        });\n        iteration++;\n    }\n    return lines;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}