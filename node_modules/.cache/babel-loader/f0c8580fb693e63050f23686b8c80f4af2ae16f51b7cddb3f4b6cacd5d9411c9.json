{"ast":null,"code":"import { ARROW_LENGTH, TOOL_ITEMS } from \"../constants\";\nimport getStroke from \"perfect-freehand\";\nimport rough from \"roughjs/bin/rough\";\nimport { getArrowHeadsCoordinates, isPointCloseToLine } from \"./math\";\nconst gen = rough.generator();\nexport const createElement = (id, x1, y1, x2, y2, {\n  type,\n  stroke,\n  fill,\n  size\n}) => {\n  const element = {\n    id,\n    x1,\n    y1,\n    x2,\n    y2,\n    type,\n    fill,\n    stroke,\n    size\n  };\n  let options = {\n    seed: id + 1,\n    // id can't be zero\n    fillStyle: \"solid\"\n  };\n  if (stroke) {\n    options.stroke = stroke;\n  }\n  if (fill) {\n    options.fill = fill;\n  }\n  if (size) {\n    options.strokeWidth = size;\n  }\n  switch (type) {\n    case TOOL_ITEMS.BRUSH:\n      {\n        const brushElement = {\n          id,\n          points: [{\n            x: x1,\n            y: y1\n          }],\n          path: new Path2D(getSvgPathFromStroke(getStroke([{\n            x: x1,\n            y: y1\n          }]))),\n          type,\n          stroke\n        };\n        return brushElement;\n      }\n    case TOOL_ITEMS.LINE:\n      element.roughEle = gen.line(x1, y1, x2, y2, options);\n      return element;\n    case TOOL_ITEMS.RECTANGLE:\n      element.roughEle = gen.rectangle(x1, y1, x2 - x1, y2 - y1, options);\n      return element;\n    case TOOL_ITEMS.CIRCLE:\n      const cx = (x1 + x2) / 2,\n        cy = (y1 + y2) / 2;\n      const width = x2 - x1,\n        height = y2 - y1;\n      element.roughEle = gen.ellipse(cx, cy, width, height, options);\n      return element;\n    case TOOL_ITEMS.ARROW:\n      const {\n        x3,\n        y3,\n        x4,\n        y4\n      } = getArrowHeadsCoordinates(x1, y1, x2, y2, ARROW_LENGTH);\n      const points = [[x1, y1], [x2, y2], [x3, y3], [x2, y2], [x4, y4]];\n      element.roughEle = gen.linearPath(points, options);\n      return element;\n    case TOOL_ITEMS.TEXT:\n      element.text = \"\";\n      return element;\n    default:\n      throw new Error(\"Type not recognized\");\n  }\n};\nexport const isPointNearElement = (element, pointX, pointY) => {\n  const {\n    x1,\n    y1,\n    x2,\n    y2,\n    type\n  } = element;\n  const context = document.getElementById(\"canvas\").getContext(\"2d\");\n  switch (type) {\n    case TOOL_ITEMS.LINE:\n    case TOOL_ITEMS.ARROW:\n      return isPointCloseToLine(x1, y1, x2, y2, pointX, pointY);\n    case TOOL_ITEMS.RECTANGLE:\n    case TOOL_ITEMS.CIRCLE:\n      return isPointCloseToLine(x1, y1, x2, y1, pointX, pointY) || isPointCloseToLine(x2, y1, x2, y2, pointX, pointY) || isPointCloseToLine(x2, y2, x1, y2, pointX, pointY) || isPointCloseToLine(x1, y2, x1, y1, pointX, pointY);\n    case TOOL_ITEMS.BRUSH:\n      return context.isPointInPath(element.path, pointX, pointY);\n    case TOOL_ITEMS.TEXT:\n      context.font = `${element.size}px Caveat`;\n      context.fillStyle = element.stroke;\n      const textWidth = context.measureText(element.text).width;\n      const textHeight = parseInt(element.size);\n      context.restore();\n      return isPointCloseToLine(x1, y1, x1 + textWidth, y1, pointX, pointY) || isPointCloseToLine(x1 + textWidth, y1, x1 + textWidth, y1 + textHeight, pointX, pointY) || isPointCloseToLine(x1 + textWidth, y1 + textHeight, x1, y1 + textHeight, pointX, pointY) || isPointCloseToLine(x1, y1 + textHeight, x1, y1, pointX, pointY);\n    default:\n      throw new Error(\"Type not recognized\");\n  }\n};\nexport const getSvgPathFromStroke = stroke => {\n  if (!stroke.length) return \"\";\n  const d = stroke.reduce((acc, [x0, y0], i, arr) => {\n    const [x1, y1] = arr[(i + 1) % arr.length];\n    acc.push(x0, y0, (x0 + x1) / 2, (y0 + y1) / 2);\n    return acc;\n  }, [\"M\", ...stroke[0], \"Q\"]);\n  d.push(\"Z\");\n  return d.join(\" \");\n};","map":{"version":3,"names":["ARROW_LENGTH","TOOL_ITEMS","getStroke","rough","getArrowHeadsCoordinates","isPointCloseToLine","gen","generator","createElement","id","x1","y1","x2","y2","type","stroke","fill","size","element","options","seed","fillStyle","strokeWidth","BRUSH","brushElement","points","x","y","path","Path2D","getSvgPathFromStroke","LINE","roughEle","line","RECTANGLE","rectangle","CIRCLE","cx","cy","width","height","ellipse","ARROW","x3","y3","x4","y4","linearPath","TEXT","text","Error","isPointNearElement","pointX","pointY","context","document","getElementById","getContext","isPointInPath","font","textWidth","measureText","textHeight","parseInt","restore","length","d","reduce","acc","x0","y0","i","arr","push","join"],"sources":["C:/Users/Ayush Hurkat/Documents/whiteboard-app/src/utils/element.js"],"sourcesContent":["import { ARROW_LENGTH, TOOL_ITEMS } from \"../constants\";\r\nimport getStroke from \"perfect-freehand\";\r\n\r\nimport rough from \"roughjs/bin/rough\";\r\nimport { getArrowHeadsCoordinates, isPointCloseToLine } from \"./math\";\r\n\r\nconst gen = rough.generator();\r\n\r\nexport const createElement = (\r\n  id,\r\n  x1,\r\n  y1,\r\n  x2,\r\n  y2,\r\n  { type, stroke, fill, size }\r\n) => {\r\n  const element = {\r\n    id,\r\n    x1,\r\n    y1,\r\n    x2,\r\n    y2,\r\n    type,\r\n    fill,\r\n    stroke,\r\n    size,\r\n  };\r\n  let options = {\r\n    seed: id + 1, // id can't be zero\r\n    fillStyle: \"solid\",\r\n  };\r\n  if (stroke) {\r\n    options.stroke = stroke;\r\n  }\r\n  if (fill) {\r\n    options.fill = fill;\r\n  }\r\n  if (size) {\r\n    options.strokeWidth = size;\r\n  }\r\n  switch (type) {\r\n    case TOOL_ITEMS.BRUSH: {\r\n      const brushElement = {\r\n        id,\r\n        points: [{ x: x1, y: y1 }],\r\n        path: new Path2D(getSvgPathFromStroke(getStroke([{ x: x1, y: y1 }]))),\r\n        type,\r\n        stroke,\r\n      };\r\n      return brushElement;\r\n    }\r\n    case TOOL_ITEMS.LINE:\r\n      element.roughEle = gen.line(x1, y1, x2, y2, options);\r\n      return element;\r\n    case TOOL_ITEMS.RECTANGLE:\r\n      element.roughEle = gen.rectangle(x1, y1, x2 - x1, y2 - y1, options);\r\n      return element;\r\n    case TOOL_ITEMS.CIRCLE:\r\n      const cx = (x1 + x2) / 2,\r\n        cy = (y1 + y2) / 2;\r\n      const width = x2 - x1,\r\n        height = y2 - y1;\r\n      element.roughEle = gen.ellipse(cx, cy, width, height, options);\r\n      return element;\r\n    case TOOL_ITEMS.ARROW:\r\n      const { x3, y3, x4, y4 } = getArrowHeadsCoordinates(\r\n        x1,\r\n        y1,\r\n        x2,\r\n        y2,\r\n        ARROW_LENGTH\r\n      );\r\n      const points = [\r\n        [x1, y1],\r\n        [x2, y2],\r\n        [x3, y3],\r\n        [x2, y2],\r\n        [x4, y4],\r\n      ];\r\n      element.roughEle = gen.linearPath(points, options);\r\n      return element;\r\n    case TOOL_ITEMS.TEXT:\r\n      element.text = \"\";\r\n      return element;\r\n    default:\r\n      throw new Error(\"Type not recognized\");\r\n  }\r\n};\r\n\r\nexport const isPointNearElement = (element, pointX, pointY) => {\r\n  const { x1, y1, x2, y2, type } = element;\r\n  const context = document.getElementById(\"canvas\").getContext(\"2d\");\r\n  switch (type) {\r\n    case TOOL_ITEMS.LINE:\r\n    case TOOL_ITEMS.ARROW:\r\n      return isPointCloseToLine(x1, y1, x2, y2, pointX, pointY);\r\n    case TOOL_ITEMS.RECTANGLE:\r\n    case TOOL_ITEMS.CIRCLE:\r\n      return (\r\n        isPointCloseToLine(x1, y1, x2, y1, pointX, pointY) ||\r\n        isPointCloseToLine(x2, y1, x2, y2, pointX, pointY) ||\r\n        isPointCloseToLine(x2, y2, x1, y2, pointX, pointY) ||\r\n        isPointCloseToLine(x1, y2, x1, y1, pointX, pointY)\r\n      );\r\n    case TOOL_ITEMS.BRUSH:\r\n      return context.isPointInPath(element.path, pointX, pointY);\r\n    case TOOL_ITEMS.TEXT:\r\n      context.font = `${element.size}px Caveat`;\r\n      context.fillStyle = element.stroke;\r\n      const textWidth = context.measureText(element.text).width;\r\n      const textHeight = parseInt(element.size);\r\n      context.restore();\r\n      return (\r\n        isPointCloseToLine(x1, y1, x1 + textWidth, y1, pointX, pointY) ||\r\n        isPointCloseToLine(\r\n          x1 + textWidth,\r\n          y1,\r\n          x1 + textWidth,\r\n          y1 + textHeight,\r\n          pointX,\r\n          pointY\r\n        ) ||\r\n        isPointCloseToLine(\r\n          x1 + textWidth,\r\n          y1 + textHeight,\r\n          x1,\r\n          y1 + textHeight,\r\n          pointX,\r\n          pointY\r\n        ) ||\r\n        isPointCloseToLine(x1, y1 + textHeight, x1, y1, pointX, pointY)\r\n      );\r\n    default:\r\n      throw new Error(\"Type not recognized\");\r\n  }\r\n};\r\n\r\nexport const getSvgPathFromStroke = (stroke) => {\r\n  if (!stroke.length) return \"\";\r\n\r\n  const d = stroke.reduce(\r\n    (acc, [x0, y0], i, arr) => {\r\n      const [x1, y1] = arr[(i + 1) % arr.length];\r\n      acc.push(x0, y0, (x0 + x1) / 2, (y0 + y1) / 2);\r\n      return acc;\r\n    },\r\n    [\"M\", ...stroke[0], \"Q\"]\r\n  );\r\n\r\n  d.push(\"Z\");\r\n  return d.join(\" \");\r\n};\r\n"],"mappings":"AAAA,SAASA,YAAY,EAAEC,UAAU,QAAQ,cAAc;AACvD,OAAOC,SAAS,MAAM,kBAAkB;AAExC,OAAOC,KAAK,MAAM,mBAAmB;AACrC,SAASC,wBAAwB,EAAEC,kBAAkB,QAAQ,QAAQ;AAErE,MAAMC,GAAG,GAAGH,KAAK,CAACI,SAAS,CAAC,CAAC;AAE7B,OAAO,MAAMC,aAAa,GAAGA,CAC3BC,EAAE,EACFC,EAAE,EACFC,EAAE,EACFC,EAAE,EACFC,EAAE,EACF;EAAEC,IAAI;EAAEC,MAAM;EAAEC,IAAI;EAAEC;AAAK,CAAC,KACzB;EACH,MAAMC,OAAO,GAAG;IACdT,EAAE;IACFC,EAAE;IACFC,EAAE;IACFC,EAAE;IACFC,EAAE;IACFC,IAAI;IACJE,IAAI;IACJD,MAAM;IACNE;EACF,CAAC;EACD,IAAIE,OAAO,GAAG;IACZC,IAAI,EAAEX,EAAE,GAAG,CAAC;IAAE;IACdY,SAAS,EAAE;EACb,CAAC;EACD,IAAIN,MAAM,EAAE;IACVI,OAAO,CAACJ,MAAM,GAAGA,MAAM;EACzB;EACA,IAAIC,IAAI,EAAE;IACRG,OAAO,CAACH,IAAI,GAAGA,IAAI;EACrB;EACA,IAAIC,IAAI,EAAE;IACRE,OAAO,CAACG,WAAW,GAAGL,IAAI;EAC5B;EACA,QAAQH,IAAI;IACV,KAAKb,UAAU,CAACsB,KAAK;MAAE;QACrB,MAAMC,YAAY,GAAG;UACnBf,EAAE;UACFgB,MAAM,EAAE,CAAC;YAAEC,CAAC,EAAEhB,EAAE;YAAEiB,CAAC,EAAEhB;UAAG,CAAC,CAAC;UAC1BiB,IAAI,EAAE,IAAIC,MAAM,CAACC,oBAAoB,CAAC5B,SAAS,CAAC,CAAC;YAAEwB,CAAC,EAAEhB,EAAE;YAAEiB,CAAC,EAAEhB;UAAG,CAAC,CAAC,CAAC,CAAC,CAAC;UACrEG,IAAI;UACJC;QACF,CAAC;QACD,OAAOS,YAAY;MACrB;IACA,KAAKvB,UAAU,CAAC8B,IAAI;MAClBb,OAAO,CAACc,QAAQ,GAAG1B,GAAG,CAAC2B,IAAI,CAACvB,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEM,OAAO,CAAC;MACpD,OAAOD,OAAO;IAChB,KAAKjB,UAAU,CAACiC,SAAS;MACvBhB,OAAO,CAACc,QAAQ,GAAG1B,GAAG,CAAC6B,SAAS,CAACzB,EAAE,EAAEC,EAAE,EAAEC,EAAE,GAAGF,EAAE,EAAEG,EAAE,GAAGF,EAAE,EAAEQ,OAAO,CAAC;MACnE,OAAOD,OAAO;IAChB,KAAKjB,UAAU,CAACmC,MAAM;MACpB,MAAMC,EAAE,GAAG,CAAC3B,EAAE,GAAGE,EAAE,IAAI,CAAC;QACtB0B,EAAE,GAAG,CAAC3B,EAAE,GAAGE,EAAE,IAAI,CAAC;MACpB,MAAM0B,KAAK,GAAG3B,EAAE,GAAGF,EAAE;QACnB8B,MAAM,GAAG3B,EAAE,GAAGF,EAAE;MAClBO,OAAO,CAACc,QAAQ,GAAG1B,GAAG,CAACmC,OAAO,CAACJ,EAAE,EAAEC,EAAE,EAAEC,KAAK,EAAEC,MAAM,EAAErB,OAAO,CAAC;MAC9D,OAAOD,OAAO;IAChB,KAAKjB,UAAU,CAACyC,KAAK;MACnB,MAAM;QAAEC,EAAE;QAAEC,EAAE;QAAEC,EAAE;QAAEC;MAAG,CAAC,GAAG1C,wBAAwB,CACjDM,EAAE,EACFC,EAAE,EACFC,EAAE,EACFC,EAAE,EACFb,YACF,CAAC;MACD,MAAMyB,MAAM,GAAG,CACb,CAACf,EAAE,EAAEC,EAAE,CAAC,EACR,CAACC,EAAE,EAAEC,EAAE,CAAC,EACR,CAAC8B,EAAE,EAAEC,EAAE,CAAC,EACR,CAAChC,EAAE,EAAEC,EAAE,CAAC,EACR,CAACgC,EAAE,EAAEC,EAAE,CAAC,CACT;MACD5B,OAAO,CAACc,QAAQ,GAAG1B,GAAG,CAACyC,UAAU,CAACtB,MAAM,EAAEN,OAAO,CAAC;MAClD,OAAOD,OAAO;IAChB,KAAKjB,UAAU,CAAC+C,IAAI;MAClB9B,OAAO,CAAC+B,IAAI,GAAG,EAAE;MACjB,OAAO/B,OAAO;IAChB;MACE,MAAM,IAAIgC,KAAK,CAAC,qBAAqB,CAAC;EAC1C;AACF,CAAC;AAED,OAAO,MAAMC,kBAAkB,GAAGA,CAACjC,OAAO,EAAEkC,MAAM,EAAEC,MAAM,KAAK;EAC7D,MAAM;IAAE3C,EAAE;IAAEC,EAAE;IAAEC,EAAE;IAAEC,EAAE;IAAEC;EAAK,CAAC,GAAGI,OAAO;EACxC,MAAMoC,OAAO,GAAGC,QAAQ,CAACC,cAAc,CAAC,QAAQ,CAAC,CAACC,UAAU,CAAC,IAAI,CAAC;EAClE,QAAQ3C,IAAI;IACV,KAAKb,UAAU,CAAC8B,IAAI;IACpB,KAAK9B,UAAU,CAACyC,KAAK;MACnB,OAAOrC,kBAAkB,CAACK,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEuC,MAAM,EAAEC,MAAM,CAAC;IAC3D,KAAKpD,UAAU,CAACiC,SAAS;IACzB,KAAKjC,UAAU,CAACmC,MAAM;MACpB,OACE/B,kBAAkB,CAACK,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAED,EAAE,EAAEyC,MAAM,EAAEC,MAAM,CAAC,IAClDhD,kBAAkB,CAACO,EAAE,EAAED,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEuC,MAAM,EAAEC,MAAM,CAAC,IAClDhD,kBAAkB,CAACO,EAAE,EAAEC,EAAE,EAAEH,EAAE,EAAEG,EAAE,EAAEuC,MAAM,EAAEC,MAAM,CAAC,IAClDhD,kBAAkB,CAACK,EAAE,EAAEG,EAAE,EAAEH,EAAE,EAAEC,EAAE,EAAEyC,MAAM,EAAEC,MAAM,CAAC;IAEtD,KAAKpD,UAAU,CAACsB,KAAK;MACnB,OAAO+B,OAAO,CAACI,aAAa,CAACxC,OAAO,CAACU,IAAI,EAAEwB,MAAM,EAAEC,MAAM,CAAC;IAC5D,KAAKpD,UAAU,CAAC+C,IAAI;MAClBM,OAAO,CAACK,IAAI,GAAG,GAAGzC,OAAO,CAACD,IAAI,WAAW;MACzCqC,OAAO,CAACjC,SAAS,GAAGH,OAAO,CAACH,MAAM;MAClC,MAAM6C,SAAS,GAAGN,OAAO,CAACO,WAAW,CAAC3C,OAAO,CAAC+B,IAAI,CAAC,CAACV,KAAK;MACzD,MAAMuB,UAAU,GAAGC,QAAQ,CAAC7C,OAAO,CAACD,IAAI,CAAC;MACzCqC,OAAO,CAACU,OAAO,CAAC,CAAC;MACjB,OACE3D,kBAAkB,CAACK,EAAE,EAAEC,EAAE,EAAED,EAAE,GAAGkD,SAAS,EAAEjD,EAAE,EAAEyC,MAAM,EAAEC,MAAM,CAAC,IAC9DhD,kBAAkB,CAChBK,EAAE,GAAGkD,SAAS,EACdjD,EAAE,EACFD,EAAE,GAAGkD,SAAS,EACdjD,EAAE,GAAGmD,UAAU,EACfV,MAAM,EACNC,MACF,CAAC,IACDhD,kBAAkB,CAChBK,EAAE,GAAGkD,SAAS,EACdjD,EAAE,GAAGmD,UAAU,EACfpD,EAAE,EACFC,EAAE,GAAGmD,UAAU,EACfV,MAAM,EACNC,MACF,CAAC,IACDhD,kBAAkB,CAACK,EAAE,EAAEC,EAAE,GAAGmD,UAAU,EAAEpD,EAAE,EAAEC,EAAE,EAAEyC,MAAM,EAAEC,MAAM,CAAC;IAEnE;MACE,MAAM,IAAIH,KAAK,CAAC,qBAAqB,CAAC;EAC1C;AACF,CAAC;AAED,OAAO,MAAMpB,oBAAoB,GAAIf,MAAM,IAAK;EAC9C,IAAI,CAACA,MAAM,CAACkD,MAAM,EAAE,OAAO,EAAE;EAE7B,MAAMC,CAAC,GAAGnD,MAAM,CAACoD,MAAM,CACrB,CAACC,GAAG,EAAE,CAACC,EAAE,EAAEC,EAAE,CAAC,EAAEC,CAAC,EAAEC,GAAG,KAAK;IACzB,MAAM,CAAC9D,EAAE,EAAEC,EAAE,CAAC,GAAG6D,GAAG,CAAC,CAACD,CAAC,GAAG,CAAC,IAAIC,GAAG,CAACP,MAAM,CAAC;IAC1CG,GAAG,CAACK,IAAI,CAACJ,EAAE,EAAEC,EAAE,EAAE,CAACD,EAAE,GAAG3D,EAAE,IAAI,CAAC,EAAE,CAAC4D,EAAE,GAAG3D,EAAE,IAAI,CAAC,CAAC;IAC9C,OAAOyD,GAAG;EACZ,CAAC,EACD,CAAC,GAAG,EAAE,GAAGrD,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,CACzB,CAAC;EAEDmD,CAAC,CAACO,IAAI,CAAC,GAAG,CAAC;EACX,OAAOP,CAAC,CAACQ,IAAI,CAAC,GAAG,CAAC;AACpB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}